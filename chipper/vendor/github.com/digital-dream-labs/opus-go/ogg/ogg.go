package ogg

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/grd/ogg"
)

// Packet aliases the ogg.Packet type and represents the struct
// submitted to SubmitPacket
type Packet = ogg.Packet

// Stream is an object that accepts Ogg packets and returns byte slices of
// the Ogg container generated by these packets as they're submitted
type Stream struct {
	stream    ogg.StreamState
	syncState ogg.SyncState
	granules  int64
	packets   int64
	anyMade   bool
	inited    bool
}

// Init initializes the underlying Ogg stream object
func (s *Stream) Init(streamId int32) {
	s.stream.Init(streamId)
	s.inited = true
}

// NewSeqPacket returns a new packet that's assumed to sequentially follow previous packets
// sent to SubmitPacket; it will have a GranulePosition equal to the last submitted packet's
// GranulePosition plus the number of samples supplied in this call. Its packet number will be
// one higher than the last packet submitted to SubmitPacket. The first packet generated by
// this function will have BOS set, otherwise no extra flags will be set.
//
// For situations (i.e. header packets) where specific granule positions and packet numbers
// are desired, those values should probably be manually checked/set after the packet is
// returned.
func (s *Stream) NewSeqPacket(buf []byte, samples int64) *Packet {
	first := !s.anyMade
	n := s.packets + 1
	if first {
		n = 0
	}
	s.anyMade = true
	return &Packet{
		Packet:     buf,
		GranulePos: s.granules + samples,
		PacketNo:   n,
		BOS:        first}
}

// SubmitPacket adds the given packet to the Ogg container and returns any bytes from completed
// pages that are output, the number of pages that were output, and any errors. If the flush
// parameter is true, it will attempt to flush a page to force data to be output; otherwise,
// the submitted packet may not trigger any output and return values of (0-length byte slice, 0, nil)
// are possible or even likely.
//
// If flush is true and no pages are output, an error is returned.
func (s *Stream) SubmitPacket(packet *Packet, flush bool) ([]byte, int, error) {
	if !s.inited {
		return nil, 0, errors.New("Packet submitted to stream before Init() called")
	}
	s.granules = packet.GranulePos
	s.packets = packet.PacketNo

	var output pageBuffer
	if err := s.stream.PacketIn(packet); err != nil {
		return nil, 0, err
	}
	var page ogg.Page
	var count int
	for s.stream.PageOut(&page) {
		if _, err := output.writePage(&page); err != nil {
			return nil, 0, err
		}
		count++
	}
	if flush {
		if s.stream.Flush(&page) {
			if _, err := output.writePage(&page); err != nil {
				return nil, 0, err
			}
			count++
		}
		if count == 0 {
			return nil, 0, errors.New("Flush requested but no data output")
		}
	}
	return output.Bytes(), count, nil
}

func (s *Stream) SubmitDecodeBytes(inBytes []byte) error {
	buf := s.syncState.Buffer(len(inBytes))
	n := copy(buf, inBytes)
	if n != len(inBytes) {
		return fmt.Errorf("Could not copy incoming bytes into sync state buffer")
	}

	checkNum := s.syncState.Wrote(n)
	if checkNum == -1 {
		return fmt.Errorf("Unable to inform sync state of written bytes")
	}
	return nil
}

func (s *Stream) ReadInfoFromHeaders() (channels int, sampleRate int, err error) {
	var headerPage ogg.Page
	var pageCode int
	pageCode = s.syncState.PageOut(&headerPage)
	if pageCode <= 0 {
		return 0, 0, fmt.Errorf("Error reading ogg header page 1")
	}

	s.stream.Init(headerPage.SerialNo())

	err = s.stream.PageIn(&headerPage)
	if err != nil {
		return 0, 0, err
	}

	var packetToDecode ogg.Packet
	code := s.stream.PacketOut(&packetToDecode)
	if code <= 0 {
		return 0, 0, fmt.Errorf("Error reading packet from ogg header page 1")
	}
	packetBytes := packetToDecode.Packet

	pageCode = s.syncState.PageOut(&headerPage)
	if pageCode <= 0 {
		return 0, 0, fmt.Errorf("Error reading ogg header page 2")
	}
	return int(packetBytes[9]), int(binary.LittleEndian.Uint32(packetBytes[12:16])), nil
}

// This will pull a packet out immediately if there is one available on the current
// page. Otherwise it will keep adding pages until one has a packet to decode or
// we run out of pages
func (s *Stream) DecodeBytesOut() ([]byte, error) {
	var packetToDecode ogg.Packet
	code := s.stream.PacketOut(&packetToDecode)
	if code > 0 {
		return packetToDecode.Packet, nil
	}
	var pageToDecode ogg.Page
	for s.syncState.PageOut(&pageToDecode) > 0 {
		err := s.stream.PageIn(&pageToDecode)
		if err != nil {
			return nil, err
		}
		for {
			code = s.stream.PacketOut(&packetToDecode)
			if code > 0 {
				return packetToDecode.Packet, nil
			} else if code == 0 {
				break
			}
		}
	}
	return nil, nil
}

// Flush attempts to flush a completed page from the Ogg container if,
// since the last page was returned, packets were submitted that did not
// return a completed page. Returns the bytes from that page if successful,
// or else an empty byte slice.
func (s *Stream) Flush() []byte {
	var page ogg.Page
	flushed := s.stream.Flush(&page)
	if !flushed {
		return []byte{}
	}
	return append(page.Header, page.Body...)
}

type pageBuffer struct {
	bytes.Buffer
}

func getWriteError(err error, n int, expected int) error {
	if err != nil {
		return err
	}
	return fmt.Errorf("Couldn't write page size %d, got %d", expected, n)
}

func (b *pageBuffer) writePage(p *ogg.Page) (int, error) {
	if n, err := b.Write(p.Header); n != len(p.Header) || err != nil {
		return 0, getWriteError(err, n, len(p.Header))
	}
	if n, err := b.Write(p.Body); n != len(p.Body) || err != nil {
		return 0, getWriteError(err, n, len(p.Body))
	}
	return len(p.Header) + len(p.Body), nil
}
